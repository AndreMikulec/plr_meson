name: plr_meson Windows experiments
run-name: Testing Creating PL/R using meson
on: [push]
jobs:
  build_test_install:
    name: ${{ matrix.compiler }} ${{ matrix.os }} ${{ matrix.FAKE }}
    runs-on: ${{ matrix.os }}
    strategy:
      # Disable fail-fast as we want results from all even if one fails.
      fail-fast: false
      matrix:
        include:

          - compiler: UCRT64
            os: windows-latest
            Platform: x64

#         - compiler: cygwin
#           os: windows-latest
# 
#         - compiler: msvc
#           os: windows-latest

    steps:

      - name: Prepare to Download Files from Github
        run: |
          git config --global core.autocrlf input
          git config --global advice.detachedHead false

      - name: Checkout Code of This Repository
        uses: actions/checkout@v3

      - name: Matrix Verification
        if: matrix.os == 'windows-latest'
        run: |
          # systeminfo
          echo "${{ matrix.compiler }} on ${{ matrix.os }}"
          if( Test-Path "C:\Program Files\PostgreSQL\14" ) { "pg x64-14 exists."  } else {  "pg x64-14 not exists." } # ONLY THIS EXISTS
          function Set-EnvVar {param($X)     Add-Content -Path ${env:GITHUB_ENV} -Value "$X"}
          #
          ${env:compiler} = "${{ matrix.compiler }}"
          Set-EnvVar "compiler=${env:compiler}"
          ${env:os} = "${{ matrix.os }}"
          Set-EnvVar "os=${env:os}"
          #
          ${env:Platform} = "${{ matrix.Platform }}"
          Set-EnvVar "Platform=${env:Platform}"
          Set-EnvVar "bit=64"
          #
          # echo "PATH: ${env:PATH}"
          # DOES set env.PATH but pollutes the output
          # Set-EnvVar "PATH=C:\ANYWHERE;${env:PATH}"
          echo "MATRIX.FAKE ${{ matrix.FAKE }}"

      - name: matrix FAKE death
        if: matrix.FAKE == ''
        run: |
          echo "DID NOT DIE"

      - name: Matrix Verification Result
        if: matrix.os == 'windows-latest'
        run: |
          echo "compiler: ${{ env.compiler }}"
          echo "PATH: ${env:PATH}"

#       # running Meson on GitHub Actions will end up using GCC rather than MSVC
#       #
#       # His fix . 
#       # https://dvdhrm.github.io/2021/04/21/meson-msvc-github-actions/
#       #
#       # `x64` for 64-bit x86 machines, `x86` for 32-bit x86 machines.
#       # https://github.com/bus1/cabuild/blob/8c91ebf06b7a5f8405cf93c89a6928e4c76967e0/action/msdevshell/action.yml
#       - name: Prepare Github Actions, MSVC, and Meson
#         if: ${{ env.os == 'windows-latest' && env.compiler == 'msvc' }}
#         uses: bus1/cabuild/action/msdevshell@v1
#         with:
#           architecture: ${{ env.msvc_architecture }}

      # 34 seconds with zero packages
      # 2 minutes and seven(7) seconds with everything
      - name: Install Windows mingw Software - 
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
          update: true
          # if a 2nd run (not the proper way to install "postgres" separately)
          # if a 2nd run DO NOT DO "update: true"
          # if a 2nd run May not be able to find "postgres"
          # 100% sure THIS IS broken
          # location: D:\
          install: >-
            mingw-w64-ucrt-x86_64-pkg-config
            mingw-w64-ucrt-x86_64-curl
            git
            mingw-w64-ucrt-x86_64-meson
            mingw-w64-ucrt-x86_64-make
            mingw-w64-ucrt-x86_64-gcc
            tar
            gzip 
            mingw-w64-ucrt-x86_64-readline
            mingw-w64-ucrt-x86_64-zlib
            mingw-w64-ucrt-x86_64-icu
            icu-devel  
            git
            flex       
            bison      
            mingw-w64-ucrt-x86_64-perl
            mingw-w64-ucrt-x86_64-winpty
            p7zip   
            tar       
            zstd
            mingw-w64-ucrt-x86_64-tools-git
            mingw-w64-ucrt-x86_64-binutils
            mingw-w64-ucrt-x86_64-diffutils
            mingw-w64-ucrt-x86_64-libxml2
            mingw-w64-ucrt-x86_64-libxslt
            mingw-w64-ucrt-x86_64-lz4
            mingw-w64-ucrt-x86_64-postgresql

      - name: mingw Who and What Place
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
      - shell: msys2 {0}
        run: |
          echo "mingw Who and What Place"
          set -x -v -e
          echo "uname: $(uname -a)"
          echo "whoami: $(whoami)"
          echo "id: $(id)"
          echo "pwd: $(pwd)"

      - name: Cache R-x.y.z Windows Installer Exe
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        uses: actions/cache@v3.3.1
        id: cacheRWindowsInstallerExe
        with:
          path: R-4.2.3-win.exe
          key:  R-4.2.3-win.exe
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1

      # five seconds
      - name: Download R for Windows R-x.y.z R-rmajor.rminor.rpatch
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' && steps.cacheRWindowsInstallerExe.outputs.cache-hit != 'true' }}
        uses: suisei-cn/actions-download-file@v1.3.0
        id: downloadfileRforWindows 
        with:
          url: https://cran.r-project.org/bin/windows/base/old/4.2.3/R-4.2.3-win.exe

      - name: Install R for Windows R-x.y.z R-rmajor.rminor.rpatch
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        run: |
          function Start-App  {param($X,$Y) Start-Process -NoNewWindow -FilePath "$X" -ArgumentList $Y }
          Start-App "R-4.2.3-win.exe" "/VERYSILENT", "/DIR=C:\RINSTALL",  "/NOICONS", "/TASKS="

      - name: Prepare Before - Meson Setup Compile and Non-Meson Manual Test
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        run: |
          function Set-EnvVar {param($X)     Add-Content -Path ${env:GITHUB_ENV} -Value "$X"}
          #
          ${env:R_HOME}="C:\Program Files\R\R-4.2.3"
          Set-EnvVar "R_HOME=${env:R_HOME}"
          #
          ${env:R_ARCH}="/x64"
          Set-EnvVar "R_ARCH=${env:R_ARCH}"
          #
          ${env:PG_HOME}=""
          Set-EnvVar "PG_HOME="

      # C:\msys${{ env.bit }}
      - name: Meson Setup Compile and Non-Meson Manual Test
        if: ${{ env.os == 'windows-latest' && env.compiler == 'UCRT64' }}
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
      - shell: msys2 {0}
        env:
          R_HOME: ${{ env.R_HOME }}
          R_ARCH: ${{ env.R_ARCH }}
          PG_HOME: ${{ env.PG_HOME }}
        run: |
          echo "Meson Setup Compile and Non-Meson Manual Test"
          set -x -v -e

          # Msys
          # export OperatingSystem=$(uname -o)

          echo "R_ARCH: ${R_ARCH}"
          echo "R_HOME: ${R_HOME}"
          echo "PG_HOME: ${PG_HOME}"

          if [    "${R_HOME}" == "" ]
          then
            echo "One must set R_HOME=value"
            exit 1
          fi

          if [ ! "${R_HOME}"  == "" ]; then export  R_HOME=$(cygpath "${R_HOME}");  fi
          if [ ! "${PG_HOME}" == "" ]; then export PG_HOME=$(cygpath "${PG_HOME}"); fi
          if [   "${PG_HOME}" == "" ]; then export PG_HOME="$(dirname $(dirname $(which postgres)))"; fi

          echo "R_HOME: ${R_HOME}"
          echo "PG_HOME: ${PG_HOME}"

          # needed so "meson" can find "libraries"
          # R Non-Sub-Architectures
          export PATH="${PG_HOME}/bin:${PATH}"
          # R    Sub-Architectures
          export PATH="${PG_HOME}/bin${R_ARCH}:${PATH}"

          # needed so "meson" can find "libraries"
          export PATH="${PG_HOME}/lib:${PATH}"
          #
          # needed so "meson" can find "libraries"
          export PATH="${PG_HOME}/bin:${PATH}"

          echo "PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
          echo "PKG_CONFIG_SYSTEM_INCLUDE_PATH: ${PKG_CONFIG_SYSTEM_INCLUDE_PATH}"
          echo "PKG_CONFIG_SYSTEM_LIBRARY_PATH: ${PKG_CONFIG_SYSTEM_LIBRARY_PATH}"

          # note "cygwin" has "no defaults"
          #
          # note mingw MSYS UCRT uses MSYSTEM_PREFIX="/ucrt64" in place of "/usr"
          # note mingw MSYS UCRT variable PKG_CONFIG_PATH at the tail also has "/ucrt64/share/pkgconfig"
          #
          # OperatingSystem Cygwin
          if [ "${PKG_CONFIG_PATH}" == "" ];                then export PKG_CONFIG_PATH="/usr/lib/pkgconfig"; fi 
          if [ "${PKG_CONFIG_SYSTEM_INCLUDE_PATH}" == "" ]; then export PKG_CONFIG_SYSTEM_INCLUDE_PATH="/usr/include"; fi 
          if [ "${PKG_CONFIG_SYSTEM_LIBRARY_PATH}" == "" ]; then export PKG_CONFIG_SYSTEM_LIBRARY_PATH="/usr/lib"; fi

          # For OperatingSystem Msys and R environment variable R_ARCH
          export PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG=${PKG_CONFIG_SYSTEM_LIBRARY_PATH}
          # MSYS2 UCRT
          # export PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG="/ucrt64/lib"

          echo "PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
          echo "PKG_CONFIG_SYSTEM_INCLUDE_PATH: ${PKG_CONFIG_SYSTEM_INCLUDE_PATH}"
          echo "PKG_CONFIG_SYSTEM_LIBRARY_PATH: ${PKG_CONFIG_SYSTEM_LIBRARY_PATH}"

          # Garantee to find the PostgreSQL libraries.
          # Some packages may also install an old "libpg" that is located in the default install location. 
          # We do not want to use that old "libpg" in compiling PL/R.
          #
          export PKG_CONFIG_PATH="${PG_HOME}/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export PKG_CONFIG_SYSTEM_INCLUDE_PATH="${PG_HOME}/include:${PKG_CONFIG_SYSTEM_INCLUDE_PATH}"
          export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PG_HOME}/bin:${PG_HOME}/lib:${PKG_CONFIG_SYSTEM_LIBRARY_PATH}"

          echo "PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
          echo "PKG_CONFIG_SYSTEM_INCLUDE_PATH: ${PKG_CONFIG_SYSTEM_INCLUDE_PATH}"
          echo "PKG_CONFIG_SYSTEM_LIBRARY_PATH: ${PKG_CONFIG_SYSTEM_LIBRARY_PATH}"

          # Part 1 of 2 of a hack to make "meson" think that "libpostgres" is a library
          # from libpq.pc create a libpostgres.pc
          if [ ! -f "${PG_HOME}/lib/pkgconfig/libpostgres.pc" ]
          then
            cat "${PG_HOME}/lib/pkgconfig/libpq.pc" | sed "s/libpq/libpostgres/g" | sed "s/-lpq/-lpostgres/" > "${PG_HOME}/lib/pkgconfig/libpostgres.pc"
          fi

          cat "${PG_HOME}/lib/pkgconfig/libpostgres.pc"

          # Part 2 of 2 of a hack to make "meson" think that "libpostgres" is a library
          # libpostgres.exe.a is not recognized as a static library
          # libpostgres.a     is     recognized as a static library
          #                         # typical Repository default install
          if [ ! -f "${PG_HOME}/lib/libpostgres.a" ] && [ ! -f "${PG_HOME}/lib/libpostgres.dll.a" ]
          then 
            #                       # meson built postgres install
            cp -f   "${PG_HOME}/lib/libpostgres.exe.a" "${PG_HOME}/lib/libpostgres.a"
          fi

          ls -alrt "${PG_HOME}"/lib/libpostgres*

          # WHAT DO THEY USE ON LINUX?
          if [ ! -f "${PKG_CONFIG_SYSTEM_LIBRARY_PATH}/libR.dll.a" ]
            then
            pushd "$R_HOME/bin$R_ARCH"
            gendef - R.dll > R.def
            dlltool --dllname R.dll --def R.def --output-lib libR.dll.a
            mv libR.dll.a "${PKG_CONFIG_SYSTEM_LIBRARY_PATH}/libR.dll.a"
          popd
          fi
          # Some environments that use R_ARCH
          # E.g. OperatingSystem  "Msys" (and Microsoft Visual C++)
          #
          if [ ! -d "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}${R_ARCH}" ] 
          then
            mkdir   "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}${R_ARCH}"
          fi
          #
          if [ ! -f "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}${R_ARCH}/libR.dll.a" ]
          then 
            cp -f   "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}/libR.dll.a" "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}${R_ARCH}/libR.dll.a"
          fi

          ls -alrt "${PKG_CONFIG_SYSTEM_LIBRARY_PATH_ORIG}${R_ARCH}/libR.dll.a"

          mkdir     "${PG_HOME}/contrib"
          #
          mkdir     "${PG_HOME}/contribplr"
          cp -R   * "${PG_HOME}/contribplr"
          #
          pushd     "${PG_HOME}/contribplr"
          rm -Rf ../contrib/plr
          rm  -f "${PG_HOME}/share/postgresql/extension/plr.control"
          rm  -f  ${PG_HOME}/share/postgresql/extension/plr--*.sql
          rm  -f "${PG_HOME}/lib/postgresql/plr.dll.a"
          rm  -f "${PG_HOME}/lib/postgresql/plr.dll"
          meson setup --prefix="${PG_HOME}/contrib/plr" -DR_HOME="${R_HOME}" -DPG_HOME="${PG_HOME}" -Db_pie=true ../contrib/plr
          meson compile -C ../contrib/plr  -v
          #
          cp plr.control "${PG_HOME}/share/postgresql/extension/plr.control"
          cp plr--*.sql  "${PG_HOME}/share/postgresql/extension"
          # 
          if [ -f "../contrib/plr/plr.dll" ];   then cp ../contrib/plr/plr.dll   "${PG_HOME}/lib/postgresql"; fi
          if [ -f "../contrib/plr/plr.dll.a" ]; then cp ../contrib/plr/plr.dll.a "${PG_HOME}/lib/postgresql"; fi
          #
          if [ -f "../contrib/plr/plr.so" ];    then cp ../contrib/plr/plr.dll   "${PG_HOME}/lib/postgresql"; fi
          # I am guessing. I will later find out.
          if [ -f "../contrib/plr/plr.so.a" ];  then cp ../contrib/plr/plr.dll.a "${PG_HOME}/lib/postgresql"; fi
          #
          mkdir     PGDATA
          initdb -D PGDATA
          pg_ctl -D PGDATA -l logfile start
          # Some environments require it
          export PGUSER=$(whoami)
          "${PG_HOME}/lib/postgresql/pgxs/src/test/regress/pg_regress" --bindir="${PG_HOME}\bin" --dbname=pl_regression plr bad_fun opt_window do out_args plr_transaction opt_window_frame || (cat regression.diffs && false)
          pg_ctl -D PGDATA -l logfile stop
          popd

